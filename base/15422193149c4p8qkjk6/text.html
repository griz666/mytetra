<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'DejaVu Sans'; font-size:11pt; font-weight:400; font-style:normal;">
<table border="0" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px;" cellspacing="2" cellpadding="0">
<tr>
<td>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a name="post-body-1771897562701863172"></a><span style=" font-family:'Sans Serif'; font-size:9pt;">П</span><span style=" font-family:'Sans Serif'; font-size:9pt;">роход робота по лабиринту является одной из классических задач для всякого рода состязаний по робототехнике. Задача сама по себе интересна, тем, что ее базовый алгоритм достаточно прост. Но в тоже время он предоставляет большой простор как для усложнения поведения робота для выхода из сложных лабиринтов, так и, наоборот, для оптимизации поведения робота, для обхода лабиринтов специфичных видов.</span></p></td>
<td>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image1542219283631u85px7u.png" /></p></td></tr></table>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Sans Serif'; font-size:9pt;">Для того, чтобы понять, как запрограммировать робота, для перемещения его по лабиринту, рекомендуется поставить себя на место робота и думать, а как бы вы начали действовать...<br /><br />Итак, вы оказались в лабиринте...<br /></span><a name="more"></a><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><img src="image15422192833juhlsqzzy.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><a name="more"></a><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><span style=" font-family:'Sans Serif'; font-size:9pt;">Нет. На самом деле, если вы робот, собранный на базе Lego Mindstorms, как только вы попали в лабиринт, он будет для вас выглядеть вот так.<br /></span><img src="image1542219283s6dcz6d3t0.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br />Да. Вы ничего не видите. У вас нет глаз. У вас нет стереозрения. Для вас расположение стен лабиринта и уж тем более наличие ответвлений и проходов – загадка. Единственное, что вы, скорее всего, знаете наверняка, что прямо под вами твердая поверхность.<br /><br />Что вы будете делать в таком случае? Идти вперед выставив руки перед собой? Не плохая идея. А потом что? И вообще, что значит &quot;вперед&quot;? А если это очень большой зал? В таком случае, есть вероятность, что, поскольку вы не видите ориентира, на который могли бы равняться, то вы будете шагать чуть-чуть в сторону. В итоге, прошагав окружность вы вернетесь на тоже место с какого начали, но так и не узнаете, что вернулись в него – так вы будете ходить очень долго.<br />Наиболее разумной идеей было бы попытаться найти опору в виде стены для какой-либо руки. Допустим, правой. Как только стена обнаружена, вы в вправе двигаться вперед или назад. Стена в таком случае будет являться вашим путеводителем, опорой в этом &quot;темном&quot; мире.<br /><br />У робота такой рукой могут быть сенсоры расстояния, касания или даже освещенности. Если робот использует сенсор касания, то во время движения в момент, когда стена потеряется, он выдаст сигнал, который будет служить для робота поводом изменить свое поведение. Если используется сенсоры расстояния, то для того, чтобы двигаться вдоль стены, не обязательно приближаться к ней вплотную – достаточно приблизится на какое-нибудь удобное расстояние и во время движения стараться находиться все время на том же расстоянии от стены. В таком случае, резкое изменение расстояния, сигнализирует о том, что роботу нужно совершить существенную корректировку своего курса, например поворот за угол.<br /></span><img src="image1542219283vfjw97hf4o.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br />Сенсор освещенности может также использоваться роботом в контексте определения расстояния – чем ближе сенсор к стене, тем больше света возвращается (от светлой стены), чем дальше от стены, тем меньше света возвращается.<br /></span><img src="image15422192839nn458cb7c.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br />Итак,как будет выглядеть наше движение?<br /><br />Когда мы рукой чувствуем стену – мы спокойно движемся. Когда стена</span><span style=" font-family:'Sans Serif'; font-size:9pt; font-weight:600;">обрывается</span><span style=" font-family:'Sans Serif'; font-size:9pt;">, значит, лабиринт в этом месте делает поворот. Мы тоже сделаем тогда поворот.<br /></span><img src="image1542219283pfyisx4lgy.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br />Если все время держать руку на стене и двигаться вперед, в конце концов, произойдет такая ситуация, когда лбом вы стукнитесь об стену – в том месте, где стена справа </span><span style=" font-family:'Sans Serif'; font-size:9pt; font-weight:600;">заканчивается</span><span style=" font-family:'Sans Serif'; font-size:9pt;">, соединяясь с другой стеной.<br /></span><img src="image15422192831rt0438lic.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br />Поэтому, чтобы уберечь свой лоб, рекомендуется вторую руку держать перед собой. Для робота второй рукой будет еще один сенсор. Причем, можно использовать как один из тех трех сенсоров, что перечислялись выше – сенсор расстояния, сенсор касания, сенсор освещенности, так и счетчики поворота оси двигателей. Если до столкновения счетчик поворота оси двигателя увеличивался на одну постоянную величину за единицу времени, то после столкновения характер изменений будет другим – за ту же единицу времени прирост будет значительно меньше - при столкновении со стеной-препятствием, двигатели начнут вращаться медленнее.<br /><br />Ответной реакцией на столкновение со стеной будет поворот к ней боком, после чего уже эта стена будет использована как &quot;опорная&quot; вашей правой рукой. Движение продолжится вдоль нее.<br /></span><img src="image1542219283a7gdr1m4s9.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br />В итоге на текущий момент, получается следующее правило обхода лабиринта: двигаемся прямо, пока под нашей рукой чувствуется стена, как только стена</span><span style=" font-family:'Sans Serif'; font-size:9pt; font-weight:600;">обрывается</span><span style=" font-family:'Sans Serif'; font-size:9pt;"> поворачиваемся </span><span style=" font-family:'Sans Serif'; font-size:9pt; font-weight:600;">направо</span><span style=" font-family:'Sans Serif'; font-size:9pt;">, чтобы найти ее и двигаемся снова вдоль стены, если же другой рукой мы ощутили </span><span style=" font-family:'Sans Serif'; font-size:9pt; font-weight:600;">стену спереди</span><span style=" font-family:'Sans Serif'; font-size:9pt;">, то поворачиваемся </span><span style=" font-family:'Sans Serif'; font-size:9pt; font-weight:600;">налево</span><span style=" font-family:'Sans Serif'; font-size:9pt;"> и используем уже эту стену для движения вдоль нее.<br /></span><img src="image1542219283wx5ugx7kin.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br />Если продолжить наблюдать за роботом, выполняющим данный алгоритм, то в итоге можно увидеть, что он достигает выхода из лабиринта:<br /></span><img src="image1542219283yzfszjb749.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br />Приведенный выше алгоритм называется &quot;Правилом правой руки&quot; и может быть успешно использован для выхода из всех лабиринтов, которые имеют выход.</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; line-height:140%;"><a name="post-body-1771897562701863172"></a><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; line-height:140%;"><a name="post-body-1771897562701863172"></a><span style=" font-family:'Sans Serif'; font-size:9pt;">С</span><span style=" font-family:'Sans Serif'; font-size:9pt;">огласно заданию, лабиринт состоит из шести секций, соединенных между собой проходами. Конфигурация проходов заранее неизвестна. Таким образом, одно из возможных конфигураций лабиринта будет выглядеть следующим образом:<br /></span><a name="more"></a><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><img src="image15422192830ugg8oxasp.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br />Где зеленая секция – место старта робота, а красная секция – место финиша.<br /><br />Напомним, что идея &quot;Правила правой руки&quot; состоит в том, что роботу все время необходимо двигаться &quot;держась&quot; правой стенки. Обрыв стены означает для робота, поиск ее с правой стороны. Если перед роботом возникает препятствие , то робот выполняет левый поворот, так что препятствие становится по правую сторону и используется роботом к новая &quot;опора&quot;, вдоль которой нужно перемещаться.<br /><br />Как результат, траекторию движения робота в приведенной выше конфигурации лабиритна можно будет отобразить как:<br /></span><img src="image1542219283jom4yi153z.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br />Видно, что траектория движения робота неоптимальна. Так, например, при заходе в области обозначенные штриховкой на рисунке ниже, робот попросту теряет время.<br /></span><img src="image1542219283shynpe60lr.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br />А что если для поиска опоры использовать не правую, а левую руку? Тогда методика обхода лабиринта будет уже называться &quot;Правилом левой руки&quot;. В ней все действия будут аналогичны, только направление движения будет меняться: роботу все время необходимо двигаться &quot;держась&quot; </span><span style=" font-family:'Sans Serif'; font-size:9pt; font-weight:600;">левой</span><span style=" font-family:'Sans Serif'; font-size:9pt;"> стенки. Обрыв стены означает для робота, поиск ее с </span><span style=" font-family:'Sans Serif'; font-size:9pt; font-weight:600;">левой</span><span style=" font-family:'Sans Serif'; font-size:9pt;"> стороны. Если перед роботом возникает препятствие , то робот выполняет </span><span style=" font-family:'Sans Serif'; font-size:9pt; font-weight:600;">правый</span><span style=" font-family:'Sans Serif'; font-size:9pt;"> поворот, так что препятствие становится по </span><span style=" font-family:'Sans Serif'; font-size:9pt; font-weight:600;">левую</span><span style=" font-family:'Sans Serif'; font-size:9pt;"> сторону и используется роботом к новая &quot;опора&quot;, вдоль которой нужно перемещаться.<br /><br />Траектория движения в этом же лабиринте изменится:<br /></span><img src="image15422192839ll6htuu32.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br />Очевидно, что &quot;Правило левой руки&quot; дает более оптимальную траекторию – т.е. робот сможет проехать лабиринт за меньшее время. И в первую очередь, в данном конкретном задании, это обуславливается положением старта и финиша в лабиринте.</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; line-height:140%;"><a name="post-body-1771897562701863172"></a><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; line-height:140%;"><a name="post-body-1771897562701863172"></a><span style=" font-family:'Sans Serif'; font-size:9pt;">Х</span><span style=" font-family:'Sans Serif'; font-size:9pt;">отя и в конкретном приведенном примере было видно, что траектория движения робота, выполняющего &quot;Правило левой руки&quot;, - более оптимальна, их этого нельзя сделать вывод, что в каждом лабиринте такой робот будет опережать робота, запрограммированного на движение по &quot;Правилу правой руки&quot;.<br /></span><a name="more"></a><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><span style=" font-family:'Sans Serif'; font-size:9pt;">Например,<br />1. Робот, двигающийся вдоль правых стенок – выполняет меньше ненужных обходов, т.е. придет к финишу быстрее. Общая длина ненужных обходов для него 1 ячейка, в то время как роботу, двигающемуся вдоль левых стенок – нужно сделать ненужных проходов длиной в 3 ячейки (одна в четвертом коридоре и две в пятом).<br /></span><img src="image1542219283j3qm744p9n.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /><br />2. На этом поле, робот, движущийся по &quot;Правилу левой руки&quot;, придет к финишу раньше. 2 ячейки против 4-х.<br /></span><img src="image15422192834hlj5axbby.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /><br />3. В данной конфигурации количество &quot;лишних&quot; заходов у обоих роботов – одинаково (по 2 ячейки).<br /></span><img src="image1542219283200o6hx0sh.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /><br />Эти три примера показывают, что для разных конфигураций лабиринтов эффективными будут разные алгоритмы. Но это нерепрезентативная выборка.<br /><br />Если провести анализ всех возможных комбинаций установленных перегородок, то получатся следующие результаты.<br /><br /></span></p>
<table border="1" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px;" cellspacing="2" cellpadding="0">
<tr>
<td>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Sans Serif'; font-size:9pt; color:#444444;">Всего различных возможных вариантов установки перегородок</span></p></td>
<td>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Sans Serif'; font-size:9pt; color:#444444;">  243  </span></p></td></tr>
<tr>
<td>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Sans Serif'; font-size:9pt; color:#444444;">&quot;Разумных&quot; вариантов, когда не никакие три сподряд идущие перегородки не будут установлены в одинковые позиции<br /></span><img src="image15422192832r08dncycl.png" /></p></td>
<td>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Sans Serif'; font-size:9pt; color:#444444;">  180  </span></p></td></tr></table>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Sans Serif'; font-size:9pt;"><br />Если теперь рассмотреть варианты прохода для каждой конфигурации лабиринта, то получится такая вот статистика:<br /></span><img src="image15422192831hjmgoddz4.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br />Где<br /></span></p>
<ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" font-family:'Sans Serif'; font-size:9pt;" style=" margin-top:8px; margin-bottom:4px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">в первой строчке – идеальные конфигурации – робот не сделает ни одного ненужного заворота.</li>
<li style=" font-family:'Sans Serif'; font-size:9pt;" style=" margin-top:0px; margin-bottom:4px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">остальных строчки для проходов с одним или несколькими &quot;ненужными&quot; заворотами в тупики. Причем, если написано два «ненужных» прохода, то это может быть заворот в один длинный тупик или два коротких – в любом случае, на их проходы тратиться почти одинаковое время.</li>
<li style=" font-family:'Sans Serif'; font-size:9pt;" style=" margin-top:0px; margin-bottom:8px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">в последней строчке – сколько &quot;ячеек&quot; придется посетить при самой неудачной конфигурации лабиринта.<br /><img src="image1542219283bi4bmb9jb1.png" /></li></ul>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Sans Serif'; font-size:9pt;"><br />Из таблицы видно, что в 45 конфигурациях лабиринта из 180 робот, обходящий алгоритм по &quot;Правилу левой руки&quot;, будет делать только верные перемещения. В то время как роботу, выполняющий программу по &quot;Правилу правой руки&quot; доступно только 13 таких конфигураций. Даже на то, что роботу выпадет конфигурация в которой ему придется сделать все го лишь два &quot;ненужных&quot; прохода., вероятность больше в случае &quot;Правила левой руки&quot; - 41 к 180, тогда как у &quot;Правила правой руки&quot; - всего 36 к 180.<br /><br />Следовательно, можно сделать вывод, что у робота, двигающегося вдоль левых стенок, вероятность прийти к финишу первым выше. Т.е. при выборе, какой именно алгоритм реализовывать у робота, выбор, безусловно, ложиться на &quot;Правило левой руки&quot;.<br /><br />Причем, если вспомнить о необходимости собирать шарики по пути движения робота (а они лежать в строго определенных позициях в 3-ем, 4-ом и 5-ом коридорах), статистика несильноизменится.<br /><br />Допустим, вы сделали достаточно умного робота, способного определять что он находися в нужном коридоре и ему нужно сделать лишний заворот для захвата шарика, даже если &quot;верный&quot; ход для движения к финишу находится не в этом направлении.<br /></span><img src="image1542219283gusg2m4v0w.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /><br />Назовем этот маневр также &quot;ненужным&quot; ходом, тогда табличка станет выглядеть следующим образом:<br /></span><img src="image1542219284w1tf493h2j.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /><br />Т.е. варианты попасть на &quot;хорошее&quot; поле у робота, работающего по &quot;Правилу левой руки&quot; все еще существенно выше.<br /><br /></span><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;">Из-за специфичного расположения зон старта финиша, этот способ дает меньше &quot;ненужных&quot; заходов в тупиковые коридоры. </span><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;"><br />Но поскольку для пободы в состязании робот должен выполнить задание как можно быстрее, заход в тупиковые коридоры крайне не желателен. Перемещение по таким коридорам не приближает робота к финишу, и робот попросту тратит в них драгоценные секунды.</span><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;"><br />Очевидно, что для того, чтобы робот определял более оптимальный маршрут, в базовую программу перемещения робота нужно добавить интеллекта. Скорее всего, это также потребует конструктивных изменений робота.</span><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><a name="more"></a><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;"><br /></span><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;">Напомним, что в конструкции всех роботов, двигающихся по &quot;Правилу левой руки&quot;, будет одинаковый элемент: сенсор расстояния/освещенности/касания будет направлен влево.</span><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><img src="image15422192841e1553gum8.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;">Рассмотрим, одну из возможных трасс, где заштрихованными отображаются те коридоры , в которых робот будет терять время, в случае, если он просто следует &quot;Правилу левой руки&quot;.</span><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><img src="image1542219284vji4z0qjvq.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;">Давайте подумаем, как можно избежать заездов в заштриховнные области?</span><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;"><br />Первый заезд в тупик возникает в тех случаях, когда робот выезжает из срединного проезда и не знает, в каком месте будет находится следующий проезд. Для нас же, сторонних наблюдателей, очевидно, что роботу бы неплохо посмотреть с какой стороны от него находится стенка и сразу двигаться в ту сторону, где стенки нет.</span><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><img src="image1542219284g87pnrz7oh.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;">Один из возможных вариантов – не закреплять сенсор расстояния жестко с левой стороны, а прикрепить его к двигателю. Еще вариант – не только сделать сенсор вращающимся, но и добавить еще один. В обоих случаях, при определенном положении робота и сенсора, у него возникает возможность &quot;увидеть&quot;, что его ждет в каждом из ответвлений – со стороны, где стенки нет, сенсор будет показывать большее расстояние.</span><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><img src="image1542219284qpb7vhabbc.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;">Если робот обнаружил такую ситуацию, он сразу же корректирует свой курс, и, таким образом, избегает &quot;ненужного&quot; поворота.</span><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;"><br />Такая же конструкция позволит оптимизировать траектория движения и для тупика второго вида.</span><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><img src="image1542219284znvh7bixut.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;">При всей простоте, этот метод для выполнения данной конкретно оптимизации, возможно, у вас не заработает. Причин несколько – погрешности измерений сенсора , помехи от других стен, слишком большой угол расположения сенсора, относительно стены, от которой должен отразиться сигнал и т.п.</span><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;"><br />Тогда решением может оказаться, автоматическое изменение конфигурации сенсоров при движени вдоль стены. Сенсоры из расположения &quot;углом&quot; начинают просто смотреть в разные стороны:</span><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><img src="image15422192843q1qg5ivc6.png" /><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;">Как видно, &quot;свободный проход&quot; в таком случае определяется достаточно просто. В то время как один сенсор работает на движение по &quot;Правилу левой руки&quot;, второй просто сообщает роботу, что заметил проход, после чего робот корректирует свое поведение.</span><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;"><br />Если и дальше рассматривать всевозможные переходы из одного коридора в другой в лабиринте такого типа, то выяснится, что предлагаемых изменений в конструкции робота будет достаточно для того, чтобы робот оптимизировал траекторию своего перемещения.</span><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;"><br /><br /></span></p>
<table border="0" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px;" cellspacing="2" cellpadding="0">
<tr>
<td>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><a href="http://nnxt.blogspot.ru/2011/03/iv.html"><span style=" font-family:'Sans Serif'; font-size:9pt; text-decoration: underline; color:#4d469c;">Предыдущий цикл статей</span></a><span style=" font-family:'Sans Serif'; font-size:9pt; color:#444444;">, в котором давались советы относительно того как выходить из лабиринта не закончился самым главным - там было объяснено</span><a href="http://nnxt.blogspot.ru/2011/02/i.html"><span style=" font-family:'Sans Serif'; font-size:9pt; text-decoration: underline; color:#4d469c;">правило правой руки</span></a><span style=" font-family:'Sans Serif'; font-size:9pt; color:#444444;">, давался </span><a href="http://nnxt.blogspot.ru/2011/02/iii_28.html"><span style=" font-family:'Sans Serif'; font-size:9pt; text-decoration: underline; color:#4d469c;">обзор тактик решения задачи</span></a><span style=" font-family:'Sans Serif'; font-size:9pt; color:#444444;"> для средней категории World Robot Olympiad 2011, </span><a href="http://nnxt.blogspot.ru/2011/03/iv.html"><span style=" font-family:'Sans Serif'; font-size:9pt; text-decoration: underline; color:#4d469c;">советы по тому, какими датчиками и как пользоваться</span></a><span style=" font-family:'Sans Serif'; font-size:9pt; color:#444444;">, но так и не было рассмотрено, как написать самую простую программу. Настало время наверстать этот момент.</span></p></td></tr></table>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;">Итак, сперва следует напомнить, какие же основные блоки определяют поведение робота в лабиринте:</span><span style=" font-family:'Sans Serif'; font-size:9pt;"><br /></span></p>
<ol style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" font-family:'Sans Serif'; font-size:9pt;" style=" margin-top:12px; margin-bottom:4px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ffffff;">Движение прямо с опросом датчиков, обнаруживающих проход справа, и датчиков, обнаруживающих столкновение с преградой</span></li>
<li style=" font-family:'Sans Serif'; font-size:9pt;" style=" margin-top:0px; margin-bottom:4px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ffffff;">Поворот направо, в случае обнаружения прохода</span></li>
<li style=" font-family:'Sans Serif'; font-size:9pt;" style=" margin-top:0px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" background-color:#ffffff;">Поворот налево, в случае обнаружения препятствия</span></li></ol>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;"><br /></span></p>
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image1542219283wx5ugx7kin.png" /><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;"> </span><a name="more"></a><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;"><br /></span><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;">В общем случае обычное движение прямо - не самый сложный элемент в программе. Теми нюансами, которые появляются в ходе такого движения, на первых порах можно пренебречь, сфокусировавшись на других основных элементах алгоритма - выполнении поворотов.<br /><br />Здесь следует ненадолго остановиться и опять вернуться к рассмотрению конструкции робота.<br /><br />Первый случай - поворот направо. Подразумевается, что он происходит после срабатывания датчика смотрящего в сторону.<br /><br /></span></p>
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image1542219284ciwo5rlfic.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;"><br />После такой остановки, робот может выполнить два возможных поворота: либо поворот одним колесом, либо поворот вокруг своей оси.<br /><br /></span></p>
<p align="center" style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Sans Serif'; font-size:9pt;"><br /></p>
<table border="0" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px;" align="center" cellspacing="2" cellpadding="0">
<tr>
<td>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image15422192847yzjf6udjo.png" /></p></td>
<td>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image154221928472v8trtbm5.png" /></p></td></tr></table>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;"><br />Видно, что после такого поворота, дальнейшее движение робота прямо приведет к столкновению со стеной. Эту проблему можно решить двумя способами:<br /></span></p>
<ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" font-family:'Sans Serif'; font-size:9pt;" style=" margin-top:8px; margin-bottom:4px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">сдвинув датчик назад<br /></li>
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:1; text-indent:0px;"><img src="image1542219284hentiskjnj.png" /></p>
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:1; text-indent:0px;"><img src="image1542219284wbhbucyoqh.png" /></p>
<li style=" font-family:'Sans Serif'; font-size:9pt;" style=" margin-top:0px; margin-bottom:8px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">или просто переместив робота после обнаружения прохода, но до выполнения поворота чуть-чуть вперед.<br /></li></ul>
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:1; text-indent:0px;"><img src="image1542219284sd0n1tuvkg.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;">Для того, чтобы закончить поворот до конца, роботу будет необходимо сдвинуться вперед, так чтобы датчик оказался вновь направлен на то место, где должна быть стена. Не имеет большого смысла делать этот действие с условием выхода &quot;пока не увижу стену&quot;, потому что в общем случае, стены может и не быть - перегородка, отделяющая две секции лабиринта, может оказаться слишком тонкой для определения датчиком. Остановка должна произойти примерно на таком же расстоянии, на котором бы робот сам остановился, обнаружив проход.<br /><br /></span></p>
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image15422192840hb4b9cbt0.png" /></p>
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image1542219284uprrgl4e9a.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;"><br />Теперь следует рассмотреть с таких же позиций разворот налево.<br /><br /></span></p>
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image1542219284w1nw5o5zjp.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;"><br />Очевидно, что для выполнения поворота роботу нужно достаточно места. И тут опять несколько способов обеспечения этого:<br /></span></p>
<ul style="margin-top: 0px; margin-bottom: 0px; margin-left: 0px; margin-right: 0px; -qt-list-indent: 1;"><li style=" font-family:'Sans Serif'; font-size:9pt;" style=" margin-top:8px; margin-bottom:4px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">обнаруживать препятствие заранее<br /></li>
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:1; text-indent:0px;"><img src="image1542219284w06n4hwwt5.png" /></p>
<li style=" font-family:'Sans Serif'; font-size:9pt;" style=" margin-top:0px; margin-bottom:8px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;">или расположить ведущие колеса тележки так, чтобы они были самой крайней задней точкой робота. Тогда робот сможет сделать разворот назад вместо того, чтобы упираться в стену при повороте вперед.<br /></li></ul>
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:1; text-indent:0px;"><img src="image1542219284c3a3vrof5x.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;">Из схемы становиться понятно, почему при таком способе расположения колес надо стараться минимизировать проекцию робота на пол: здесь следует рассматривать вертикальное расположение и блока и колес. Иначе после разворота датчик, отслеживающий проход будет располагаться слишком далеко от стены, что может приводить к ложным срабатываниям - он будет думать, что увидел проход.<br /><br />Идеальной будет комбинация обеих вариантов - это позволит роботу двигаться достаточно близко к стене и иметь возможность заранее выполнять повороты в случае обнаружения препятствия.<br /><br />Что ж, с конструкцией более-менее стало понятно, с тем как выполнять развороты тоже. В идеале, после таких экспериментов должны остаться два готовых набора блоков, которые можно будет впоследствии вставлять в основную программу. Имеет смысл занести эти куски программы в собственные блоки.<br /><br /></span></p>
<p align="center" style="-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:'Sans Serif'; font-size:9pt;"><br /></p>
<table border="0" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px;" align="center" cellspacing="2" cellpadding="0">
<tr>
<td>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image1542219284phfst0gyzg.png" /></p></td>
<td>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image1542219284nbgae07bwg.png" /></p></td></tr></table>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;"><br />Структура основной программы однозначно диктуется правилом правой руки:<br /><br /></span></p>
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image1542219284w9k7cvy1q3.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;"><br />Алгоритм начинает свое выполнение с движение вперед. Как уже говорилось, в общем случае, это может быть обычное движение.<br /><br />Затем, друг за другом идет проверка на обнаружение прохода в правой стене, либо на обнаружение столкновения с препятствием. И, в зависимости от того, какая проверка сработала, вызываются блоки поворотов. Если никакая проверка не сработала в этот момент времени, то в следующий момент времени нужно сделать еще одну проверку, а потом еще и еще.<br /><br />Очевидно, что после выполнения поворотов нужно опять продолжить движение вперед, и опять перейти к проверкам на проход или препятствие.<br /><br /></span></p>
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image1542219284ev19nu93tp.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;"><br />Такой алгоритм обладает недостатком: его сложно реализовывать на языке NXT-G (да и на других языках тоже), поскольку он имеет две точки возврата после выполнения одних и тех же повторяющихся действий. К тому же, единожды включив двигатели на движение вперед после старта или после поворотов, этот алгоритм не подразумевает попытку подправить свое движение, если возникнет необходимость для </span><a href="http://nnxt.blogspot.ru/2011/02/iii.html"><span style=" font-family:'Sans Serif'; font-size:9pt; text-decoration: underline; color:#4d469c; background-color:#ffffff;">перемещения ровно вдоль стены</span></a><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;">. Логично было бы все время выполнять периодическую корректировку или просто добиться упрощения алгоритма, принимая во внимание, что команды &quot;включить мотор&quot; не блокируют дальнейшую работу алгоритма, а передают управление следующим инструкциям.<br /><br /></span></p>
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image1542219284zwgvmvvum8.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;"><br />В итоге, программа на языке NXT-G будет похожа на подобную конструкцию:<br /><br /></span></p>
<p align="center" style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><img src="image1542219284aixupp5nqv.png" /></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Sans Serif'; font-size:9pt; background-color:#ffffff;"><br />Как уже говорилось, блок движение вперед может быть замещено специальным блоком, который бы обеспечивал перемещение вдоль стены. Хотя во многих случаях эта проблема может быть решена чисто механически: у робота с нужно стороны устанавливаются ролики или направляющие, которые не позволяют ему слишком приблизиться к стене.</span></p></body></html>